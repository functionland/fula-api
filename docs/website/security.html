<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Security & Encryption - Fula API Documentation</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/security.css">
    <script>
        (function() {
            const saved = localStorage.getItem('fula-docs-theme');
            if (saved) document.documentElement.setAttribute('data-theme', saved);
        })();
    </script>
</head>
<body>
    <!-- Mobile Header -->
    <header class="mobile-header">
        <button class="hamburger" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <span class="logo-text">Fula API</span>
        <div class="mobile-header-actions">
            <button class="theme-toggle" aria-label="Toggle theme">
                <span class="icon-sun">â˜€ï¸</span>
                <span class="icon-moon">ğŸŒ™</span>
            </button>
        </div>
    </header>
    
    <div class="sidebar-overlay"></div>
    
    <nav class="sidebar">
        <div class="sidebar-header">
            <div class="logo">
                <h1>Fula API</h1>
                <span class="version">v0.1.0</span>
            </div>
            <button class="theme-toggle" aria-label="Toggle theme">
                <span class="icon-sun">â˜€ï¸</span>
                <span class="icon-moon">ğŸŒ™</span>
            </button>
        </div>
        <div class="nav-section">
            <h3>Documentation</h3>
            <ul>
                <li><a href="index.html">Introduction</a></li>
                <li><a href="security.html" class="active">Security & Encryption</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li><a href="sdk.html">SDK Examples</a></li>
                <li><a href="platforms.html">Platform Guides</a></li>
            </ul>
        </div>
        <div class="nav-section">
            <h3>On This Page</h3>
            <ul>
                <li><a href="#overview">Security Overview</a></li>
                <li><a href="#trust-model">Trust Model</a></li>
                <li><a href="#api-auth">API Authentication</a></li>
                <li><a href="#encryption-flow">Encryption Flow</a></li>
                <li><a href="#key-architecture">Key Architecture</a></li>
                <li><a href="#hpke">HPKE Implementation</a></li>
                <li><a href="#symmetric">Symmetric Encryption</a></li>
                <li><a href="#integrity">Data Integrity</a></li>
                <li><a href="#key-management">Key Management</a></li>
                <li><a href="#sharing">Secure Sharing</a></li>
                <li><a href="#complete-sharing-example">Complete Sharing Example</a></li>
                <li><a href="#secret-links">Secret Links</a></li>
                <li><a href="#share-modes">Share Modes</a></li>
                <li><a href="#async-inbox">Async Inbox</a></li>
                <li><a href="#subtree-keys">Subtree Keys</a></li>
                <li><a href="#key-rotation-detail">Key Rotation</a></li>
                <li><a href="#metadata-privacy">Metadata Privacy</a></li>
                <li><a href="#security-guarantees">Security Guarantees</a></li>
                <li><a href="#threat-model">Threat Model</a></li>
                <li><a href="#multi-device">Multi-Device</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
            </ul>
        </div>
    </nav>

    <main class="content security-content">
        <!-- Hero Section -->
        <section class="hero security-hero">
            <div class="hero-content">
                <h1>ğŸ”’ Security & Encryption</h1>
                <p class="hero-subtitle">In-Depth Technical Documentation of Fula's Cryptographic Implementation</p>
                <div class="hero-badges">
                    <span class="badge-item">ğŸ›¡ï¸ Quantum-Safe</span>
                    <span class="badge-item">ğŸ” HPKE (RFC 9180)</span>
                    <span class="badge-item">âš¡ AES-256-GCM</span>
                    <span class="badge-item">ğŸ”‘ X25519 + ML-KEM-768</span>
                    <span class="badge-item">âœ… BLAKE3</span>
                </div>
            </div>
        </section>

        <!-- Security Overview -->
        <section id="overview" class="security-section">
            <h2>Security Overview</h2>
            <div class="overview-content">
                <p>Fula implements a <strong>Trust-No-One (TNO)</strong> security model where all encryption happens client-side. Storage nodes and the gateway <strong>never</strong> see your plaintext data or encryption keys.</p>
                
                <div class="security-summary-grid">
                    <div class="summary-card">
                        <div class="summary-icon">ğŸ”</div>
                        <h3>Client-Side Encryption</h3>
                        <p>All encryption/decryption happens on your device before data leaves</p>
                    </div>
                    <div class="summary-card">
                        <div class="summary-icon">ğŸ”‘</div>
                        <h3>User-Held Keys</h3>
                        <p>Only you possess the private keys needed to decrypt your data</p>
                    </div>
                    <div class="summary-card">
                        <div class="summary-icon">âœ…</div>
                        <h3>Verified Integrity</h3>
                        <p>Cryptographic proofs detect any tampering, even from malicious nodes</p>
                    </div>
                    <div class="summary-card">
                        <div class="summary-icon">ğŸ”„</div>
                        <h3>Forward Secrecy</h3>
                        <p>Ephemeral keys ensure past communications remain secure</p>
                    </div>
                </div>

                <div class="crypto-stack">
                    <h3>Cryptographic Primitives Stack</h3>
                    <table class="crypto-table">
                        <thead>
                            <tr>
                                <th>Layer</th>
                                <th>Algorithm</th>
                                <th>Purpose</th>
                                <th>Security Level</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr class="highlight-row">
                                <td>ğŸ›¡ï¸ Quantum-Safe KEM</td>
                                <td><strong>X25519 + ML-KEM-768</strong></td>
                                <td>Hybrid key encapsulation (classical + post-quantum)</td>
                                <td>NIST Level 3 + 128-bit classical</td>
                            </tr>
                            <tr>
                                <td>Key Exchange</td>
                                <td><strong>X25519</strong></td>
                                <td>Classical Elliptic Curve Diffie-Hellman</td>
                                <td>128-bit classical</td>
                            </tr>
                            <tr>
                                <td>Post-Quantum KEM</td>
                                <td><strong>ML-KEM-768 (Kyber)</strong></td>
                                <td>NIST FIPS 203 lattice-based KEM</td>
                                <td>192-bit post-quantum (NIST Level 3)</td>
                            </tr>
                            <tr>
                                <td>Key Derivation</td>
                                <td><strong>HKDF-SHA256</strong></td>
                                <td>Combine X25519 + ML-KEM shared secrets</td>
                                <td>256-bit output</td>
                            </tr>
                            <tr>
                                <td>Symmetric Encryption</td>
                                <td><strong>AES-256-GCM</strong></td>
                                <td>Authenticated encryption of data</td>
                                <td>256-bit (quantum-resistant)</td>
                            </tr>
                            <tr>
                                <td>Alternative Cipher</td>
                                <td><strong>ChaCha20-Poly1305</strong></td>
                                <td>Authenticated encryption (software-optimized)</td>
                                <td>256-bit (quantum-resistant)</td>
                            </tr>
                            <tr>
                                <td>Hashing</td>
                                <td><strong>BLAKE3</strong></td>
                                <td>Content addressing, integrity verification</td>
                                <td>256-bit (quantum-resistant)</td>
                            </tr>
                            <tr>
                                <td>Streaming Verification</td>
                                <td><strong>Bao</strong></td>
                                <td>Incremental integrity verification</td>
                                <td>Merkle tree based</td>
                            </tr>
                        </tbody>
                    </table>
                    <div class="quantum-note">
                        <strong>ğŸ›¡ï¸ Post-Quantum Security:</strong> The hybrid X25519 + ML-KEM-768 approach provides defense-in-depth. 
                        If quantum computers break X25519, ML-KEM-768 still protects your data. 
                        If ML-KEM has unforeseen weaknesses, X25519 provides classical security.
                        ML-KEM-768 is NIST FIPS 203 standardized (formerly Kyber768).
                    </div>
                </div>
            </div>
        </section>

        <!-- Trust Model -->
        <section id="trust-model" class="security-section alt-bg">
            <h2>Trust Model</h2>
            <div class="trust-model-content">
                <div class="trust-diagram">
                    <div class="trust-zone trusted">
                        <div class="zone-header">ğŸŸ¢ Trusted Zone (Your Device)</div>
                        <div class="zone-content">
                            <div class="zone-item">
                                <strong>Private Keys</strong>
                                <span>Never leave your device</span>
                            </div>
                            <div class="zone-item">
                                <strong>Plaintext Data</strong>
                                <span>Only exists here</span>
                            </div>
                            <div class="zone-item">
                                <strong>Encryption/Decryption</strong>
                                <span>Performed locally</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="trust-arrow">
                        <span class="arrow-label">Encrypted Data Only</span>
                        <span class="arrow-icon">â†’</span>
                    </div>
                    
                    <div class="trust-zone untrusted">
                        <div class="zone-header">ğŸ”´ Untrusted Zone (Network)</div>
                        <div class="zone-content">
                            <div class="zone-item">
                                <strong>Fula Gateway</strong>
                                <span>Sees only ciphertext</span>
                            </div>
                            <div class="zone-item">
                                <strong>IPFS Nodes</strong>
                                <span>Store encrypted blocks</span>
                            </div>
                            <div class="zone-item">
                                <strong>Network Transport</strong>
                                <span>All data is encrypted</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="trust-assumptions">
                    <h3>Security Assumptions</h3>
                    <ul>
                        <li><strong>Your device is secure</strong> - If compromised, keys can be extracted</li>
                        <li><strong>Cryptographic primitives are secure</strong> - X25519, AES-256-GCM, BLAKE3 are industry-standard</li>
                        <li><strong>Random number generator is secure</strong> - Using OS-provided CSPRNG (OsRng)</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- API Authentication -->
        <section id="api-auth" class="security-section">
            <h2>API Authentication</h2>
            <p class="section-intro">Fula supports both Bearer tokens and AWS Signature V4, enabling full S3 SDK compatibility.</p>

            <div class="auth-content">
                <div class="auth-methods">
                    <h3>Authentication Methods</h3>
                    <div class="methods-grid">
                        <div class="method-card">
                            <h4>ğŸ”‘ Bearer Token (Simple)</h4>
                            <p>For HTTP clients, REST APIs, and custom integrations.</p>
                            <div class="code-snippet">
                                <pre>Authorization: Bearer eyJhbGciOiJIUzI1NiIs...</pre>
                            </div>
                        </div>
                        <div class="method-card">
                            <h4>ğŸ“¦ AWS Signature V4 (S3 Compatible)</h4>
                            <p>For boto3, AWS CLI, aws-sdk-js, and all S3 tools.</p>
                            <div class="code-snippet">
                                <pre>Authorization: AWS4-HMAC-SHA256 
  Credential=JWT:eyJhbGci.../20231207/us-east-1/s3/aws4_request,
  SignedHeaders=host;x-amz-date,
  Signature=abc123...</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="auth-sigv4">
                    <h3>AWS Sig V4 with JWT</h3>
                    <p>Embed your JWT token in the AWS access key with a <code>JWT:</code> prefix. This enables full compatibility with standard S3 clients while maintaining JWT-based authentication.</p>
                    
                    <div class="code-snippet">
                        <pre># Python (boto3)
import boto3

s3 = boto3.client('s3',
    endpoint_url='https://gateway.example.com',
    aws_access_key_id=f'JWT:{jwt_token}',  # JWT embedded here
    aws_secret_access_key='not-used',       # Not validated
    region_name='us-east-1'
)

s3.put_object(Bucket='my-bucket', Key='file.txt', Body=b'Hello!')</pre>
                    </div>

                    <div class="code-snippet">
                        <pre># AWS CLI (~/.aws/credentials)
[fula]
aws_access_key_id = JWT:eyJhbGciOiJIUzI1NiIs...
aws_secret_access_key = not-used

# Usage:
aws s3 cp file.txt s3://my-bucket/ --endpoint-url https://gateway.example.com --profile fula</pre>
                    </div>

                    <div class="code-snippet">
                        <pre>// JavaScript (AWS SDK v3)
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";

const s3 = new S3Client({
  endpoint: "https://gateway.example.com",
  region: "us-east-1",
  forcePathStyle: true,
  credentials: {
    accessKeyId: `JWT:${jwtToken}`,
    secretAccessKey: "not-used"
  }
});

await s3.send(new PutObjectCommand({ Bucket: "my-bucket", Key: "file.txt", Body: "Hello!" }));</pre>
                    </div>
                </div>

                <div class="auth-security">
                    <h3>Security Properties</h3>
                    <ul>
                        <li><strong>JWT Validation:</strong> Full signature, expiry, and claims validation</li>
                        <li><strong>Replay Protection:</strong> x-amz-date must be within 15 minutes</li>
                        <li><strong>Scope Enforcement:</strong> JWT scopes control read/write/delete permissions</li>
                        <li><strong>S3 Compatibility:</strong> Works with boto3, AWS CLI, aws-sdk-js, and all S3 tools</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Encryption Flow -->
        <section id="encryption-flow" class="security-section">
            <h2>Encryption Flow</h2>
            <p class="section-intro">Complete data flow from plaintext to encrypted storage and back.</p>

            <div class="flow-diagram-detailed">
                <h3>ğŸ“¤ Upload (Encryption) Flow</h3>
                <div class="flow-steps">
                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">1</span>
                            <span class="step-title">Generate DEK</span>
                        </div>
                        <div class="step-body">
                            <p>A fresh 256-bit Data Encryption Key (DEK) is generated using CSPRNG for each object.</p>
                            <div class="code-snippet">
                                <pre>DEK = random_bytes(32)  // 256 bits from OsRng</pre>
                            </div>
                        </div>
                    </div>

                    <div class="flow-connector-v"></div>

                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">2</span>
                            <span class="step-title">Encrypt Data with DEK</span>
                        </div>
                        <div class="step-body">
                            <p>Plaintext is encrypted using AES-256-GCM with a random 96-bit nonce.</p>
                            <div class="code-snippet">
                                <pre>nonce = random_bytes(12)  // 96 bits
ciphertext = AES-256-GCM.encrypt(DEK, nonce, plaintext)
// ciphertext includes 128-bit authentication tag</pre>
                            </div>
                        </div>
                    </div>

                    <div class="flow-connector-v"></div>

                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">3</span>
                            <span class="step-title">Wrap DEK with HPKE</span>
                        </div>
                        <div class="step-body">
                            <p>The DEK is encrypted using HPKE for the owner's public key.</p>
                            <div class="code-snippet">
                                <pre>ephemeral_secret = X25519.generate()
ephemeral_public = X25519.public_key(ephemeral_secret)
shared_secret = X25519.dh(ephemeral_secret, recipient_public)
wrap_key = BLAKE3.derive_key("fula-hpke-v1", shared_secret)
wrapped_DEK = AES-256-GCM.encrypt(wrap_key, nonce2, DEK)</pre>
                            </div>
                        </div>
                    </div>

                    <div class="flow-connector-v"></div>

                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">4</span>
                            <span class="step-title">Store with Metadata</span>
                        </div>
                        <div class="step-body">
                            <p>Ciphertext is uploaded with encryption metadata (nonce, wrapped DEK, ephemeral public key).</p>
                            <div class="code-snippet">
                                <pre>metadata = {
  "x-fula-encrypted": "true",
  "x-fula-encryption": {
    "version": 1,
    "algorithm": "AES-256-GCM",
    "nonce": base64(nonce),
    "wrapped_key": {
      "ephemeral_public": base64(ephemeral_public),
      "ciphertext": base64(wrapped_DEK)
    }
  }
}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <h3>ğŸ“¥ Download (Decryption) Flow</h3>
                <div class="flow-steps">
                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">1</span>
                            <span class="step-title">Fetch Encrypted Data</span>
                        </div>
                        <div class="step-body">
                            <p>Retrieve ciphertext and encryption metadata from the gateway.</p>
                        </div>
                    </div>

                    <div class="flow-connector-v"></div>

                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">2</span>
                            <span class="step-title">Unwrap DEK</span>
                        </div>
                        <div class="step-body">
                            <p>Use your secret key to derive shared secret and decrypt the DEK.</p>
                            <div class="code-snippet">
                                <pre>shared_secret = X25519.dh(your_secret_key, ephemeral_public)
wrap_key = BLAKE3.derive_key("fula-hpke-v1", shared_secret)
DEK = AES-256-GCM.decrypt(wrap_key, nonce2, wrapped_DEK)</pre>
                            </div>
                        </div>
                    </div>

                    <div class="flow-connector-v"></div>

                    <div class="flow-step-detailed">
                        <div class="step-header">
                            <span class="step-num">3</span>
                            <span class="step-title">Decrypt Data</span>
                        </div>
                        <div class="step-body">
                            <p>Use the recovered DEK to decrypt the ciphertext.</p>
                            <div class="code-snippet">
                                <pre>plaintext = AES-256-GCM.decrypt(DEK, nonce, ciphertext)
// Authentication tag verified automatically</pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Key Architecture -->
        <section id="key-architecture" class="security-section alt-bg">
            <h2>Key Architecture (KEK/DEK)</h2>
            <p class="section-intro">Fula uses a two-tier key hierarchy for efficient and secure encryption.</p>

            <div class="key-arch-diagram">
                <div class="key-tier kek-tier">
                    <div class="tier-header">
                        <span class="tier-icon">ğŸ”‘</span>
                        <span class="tier-title">KEK (Key Encryption Key)</span>
                    </div>
                    <div class="tier-body">
                        <div class="tier-details">
                            <div class="detail-item">
                                <strong>Type:</strong> X25519 Key Pair (Asymmetric)
                            </div>
                            <div class="detail-item">
                                <strong>Size:</strong> 256-bit (32 bytes)
                            </div>
                            <div class="detail-item">
                                <strong>Lifetime:</strong> Long-lived (until rotation)
                            </div>
                            <div class="detail-item">
                                <strong>Purpose:</strong> Encrypt/wrap DEKs, enable sharing
                            </div>
                        </div>
                        <div class="key-components">
                            <div class="key-component">
                                <span class="component-label">Secret Key</span>
                                <span class="component-desc">Kept private, never transmitted</span>
                            </div>
                            <div class="key-component">
                                <span class="component-label">Public Key</span>
                                <span class="component-desc">Shared freely for receiving encrypted data</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="key-arrow">
                    <span>Wraps â†“</span>
                </div>

                <div class="key-tier dek-tier">
                    <div class="tier-header">
                        <span class="tier-icon">ğŸ—ï¸</span>
                        <span class="tier-title">DEK (Data Encryption Key)</span>
                    </div>
                    <div class="tier-body">
                        <div class="tier-details">
                            <div class="detail-item">
                                <strong>Type:</strong> AES-256 Key (Symmetric)
                            </div>
                            <div class="detail-item">
                                <strong>Size:</strong> 256-bit (32 bytes)
                            </div>
                            <div class="detail-item">
                                <strong>Lifetime:</strong> Per-object (unique for each file)
                            </div>
                            <div class="detail-item">
                                <strong>Purpose:</strong> Encrypt actual file content
                            </div>
                        </div>
                    </div>
                </div>

                <div class="key-arrow">
                    <span>Encrypts â†“</span>
                </div>

                <div class="key-tier data-tier">
                    <div class="tier-header">
                        <span class="tier-icon">ğŸ“„</span>
                        <span class="tier-title">Your Data</span>
                    </div>
                    <div class="tier-body">
                        <p>Files, photos, documents, any content you store</p>
                    </div>
                </div>
            </div>

            <div class="key-benefits">
                <h3>Benefits of KEK/DEK Architecture</h3>
                <div class="benefits-grid">
                    <div class="benefit-card">
                        <strong>ğŸ”„ Efficient Key Rotation</strong>
                        <p>Rotate KEK without re-encrypting all data - just re-wrap existing DEKs</p>
                    </div>
                    <div class="benefit-card">
                        <strong>ğŸ¤ Secure Sharing</strong>
                        <p>Share access by wrapping DEK with recipient's public key</p>
                    </div>
                    <div class="benefit-card">
                        <strong>âš¡ Performance</strong>
                        <p>Symmetric DEKs are fast; asymmetric KEK only used for small DEKs</p>
                    </div>
                    <div class="benefit-card">
                        <strong>ğŸ”’ Key Isolation</strong>
                        <p>Compromise of one DEK doesn't affect other files</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- HPKE Implementation -->
        <section id="hpke" class="security-section">
            <h2>HPKE Implementation</h2>
            <p class="section-intro">Hybrid Public Key Encryption following RFC 9180 for secure key encapsulation.</p>

            <div class="hpke-details">
                <div class="hpke-config">
                    <h3>HPKE Configuration</h3>
                    <table class="config-table">
                        <tr>
                            <td><strong>KEM (Key Encapsulation)</strong></td>
                            <td>DHKEM(X25519, HKDF-SHA256)</td>
                        </tr>
                        <tr>
                            <td><strong>KDF (Key Derivation)</strong></td>
                            <td>BLAKE3 with context "fula-hpke-v1"</td>
                        </tr>
                        <tr>
                            <td><strong>AEAD (Encryption)</strong></td>
                            <td>AES-256-GCM (default) or ChaCha20-Poly1305</td>
                        </tr>
                    </table>
                </div>

                <div class="hpke-diagram">
                    <h3>HPKE Encryption Process</h3>
                    <div class="diagram-box">
                        <pre class="diagram-ascii">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         SENDER (Encryptor)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Ephemeral   â”‚         â”‚        Recipient's Public Key         â”‚  â”‚
â”‚  â”‚ Secret Key  â”‚         â”‚         (known to sender)             â”‚  â”‚
â”‚  â”‚ (random)    â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                          â”‚                        â”‚
â”‚         â”‚                                 â”‚                        â”‚
â”‚         â–¼                                 â–¼                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              X25519 Diffie-Hellman Key Exchange               â”‚  â”‚
â”‚  â”‚     shared_secret = DH(ephemeral_secret, recipient_public)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                 â”‚                                   â”‚
â”‚                                 â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚               BLAKE3 Key Derivation Function                  â”‚  â”‚
â”‚  â”‚        encryption_key = derive_key("fula-hpke-v1",            â”‚  â”‚
â”‚  â”‚                                    shared_secret)             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                 â”‚                                   â”‚
â”‚                                 â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                  AES-256-GCM Encryption                       â”‚  â”‚
â”‚  â”‚        ciphertext = encrypt(encryption_key, nonce, DEK)       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â”‚  OUTPUT: { ephemeral_public_key, nonce, ciphertext }               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       RECIPIENT (Decryptor)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Recipient's â”‚         â”‚       Ephemeral Public Key            â”‚  â”‚
â”‚  â”‚ Secret Key  â”‚         â”‚       (from ciphertext)               â”‚  â”‚
â”‚  â”‚ (private)   â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                          â”‚                        â”‚
â”‚         â”‚                                 â”‚                        â”‚
â”‚         â–¼                                 â–¼                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              X25519 Diffie-Hellman Key Exchange               â”‚  â”‚
â”‚  â”‚     shared_secret = DH(recipient_secret, ephemeral_public)    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                 â”‚                                   â”‚
â”‚                                 â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚           Same shared_secret â†’ Same encryption_key            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                 â”‚                                   â”‚
â”‚                                 â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                  AES-256-GCM Decryption                       â”‚  â”‚
â”‚  â”‚            DEK = decrypt(encryption_key, nonce,               â”‚  â”‚
â”‚  â”‚                         ciphertext)                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
                    </div>
                </div>

                <div class="hpke-properties">
                    <h3>Security Properties</h3>
                    <div class="properties-list">
                        <div class="property-item">
                            <span class="property-icon">âœ…</span>
                            <div class="property-content">
                                <strong>Forward Secrecy</strong>
                                <p>Each encryption uses a fresh ephemeral key pair. Compromise of long-term keys doesn't decrypt past messages.</p>
                            </div>
                        </div>
                        <div class="property-item">
                            <span class="property-icon">âœ…</span>
                            <div class="property-content">
                                <strong>Recipient Authentication</strong>
                                <p>Only the holder of the recipient's secret key can derive the shared secret and decrypt.</p>
                            </div>
                        </div>
                        <div class="property-item">
                            <span class="property-icon">âœ…</span>
                            <div class="property-content">
                                <strong>Ciphertext Integrity</strong>
                                <p>AES-GCM provides authenticated encryption - any tampering is detected.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Symmetric Encryption -->
        <section id="symmetric" class="security-section alt-bg">
            <h2>Symmetric Encryption (AEAD)</h2>
            <p class="section-intro">Authenticated Encryption with Associated Data for file content.</p>

            <div class="symmetric-details">
                <div class="cipher-options">
                    <h3>Supported Ciphers</h3>
                    <div class="cipher-grid">
                        <div class="cipher-card primary">
                            <div class="cipher-badge">Default</div>
                            <h4>AES-256-GCM</h4>
                            <ul>
                                <li><strong>Key Size:</strong> 256 bits (32 bytes)</li>
                                <li><strong>Nonce Size:</strong> 96 bits (12 bytes)</li>
                                <li><strong>Tag Size:</strong> 128 bits (16 bytes)</li>
                                <li><strong>Best For:</strong> Hardware with AES-NI support</li>
                            </ul>
                        </div>
                        <div class="cipher-card">
                            <div class="cipher-badge alt">Alternative</div>
                            <h4>ChaCha20-Poly1305</h4>
                            <ul>
                                <li><strong>Key Size:</strong> 256 bits (32 bytes)</li>
                                <li><strong>Nonce Size:</strong> 96 bits (12 bytes)</li>
                                <li><strong>Tag Size:</strong> 128 bits (16 bytes)</li>
                                <li><strong>Best For:</strong> Software-only implementations</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="aead-structure">
                    <h3>Ciphertext Structure</h3>
                    <div class="structure-diagram">
                        <div class="structure-row">
                            <div class="structure-item ciphertext-part">
                                <span class="part-label">Ciphertext</span>
                                <span class="part-desc">Encrypted plaintext (same length as input)</span>
                            </div>
                            <div class="structure-item tag-part">
                                <span class="part-label">Auth Tag</span>
                                <span class="part-desc">16 bytes</span>
                            </div>
                        </div>
                        <div class="structure-formula">
                            <code>output_length = plaintext_length + 16 bytes (tag)</code>
                        </div>
                    </div>
                </div>

                <div class="nonce-handling">
                    <h3>Nonce Generation</h3>
                    <div class="nonce-info">
                        <p><strong>âš ï¸ Critical:</strong> Nonces must NEVER be reused with the same key.</p>
                        <div class="nonce-strategy">
                            <h4>Fula's Strategy: Random Nonces</h4>
                            <ul>
                                <li>96-bit nonces generated from CSPRNG (OsRng)</li>
                                <li>Collision probability: ~2<sup>-48</sup> after 2<sup>48</sup> encryptions</li>
                                <li>Each file gets a unique DEK, so nonce space is per-DEK</li>
                                <li>Safe for virtually unlimited encryptions per file</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Data Integrity -->
        <section id="integrity" class="security-section">
            <h2>Data Integrity Verification</h2>
            <p class="section-intro">Cryptographic guarantees that your data hasn't been tampered with.</p>

            <div class="integrity-details">
                <div class="integrity-layers">
                    <h3>Multi-Layer Integrity</h3>
                    <div class="layers-grid">
                        <div class="layer-card">
                            <div class="layer-num">1</div>
                            <h4>AEAD Authentication Tag</h4>
                            <p>Every encrypted block includes a 128-bit authentication tag that verifies both ciphertext integrity and the encryption key used.</p>
                            <div class="layer-check">
                                <span class="check-icon">âœ…</span>
                                <span>Detects: bit flips, truncation, appending</span>
                            </div>
                        </div>
                        <div class="layer-card">
                            <div class="layer-num">2</div>
                            <h4>Content Addressing (CID)</h4>
                            <p>Every block stored in IPFS has a CID derived from its BLAKE3 hash. Retrieving by CID guarantees content matches.</p>
                            <div class="layer-check">
                                <span class="check-icon">âœ…</span>
                                <span>Detects: storage corruption, node manipulation</span>
                            </div>
                        </div>
                        <div class="layer-card">
                            <div class="layer-num">3</div>
                            <h4>Bao Streaming Verification</h4>
                            <p>For large files, Bao provides Merkle tree-based verification allowing you to verify chunks before downloading the entire file.</p>
                            <div class="layer-check">
                                <span class="check-icon">âœ…</span>
                                <span>Detects: partial corruption in large files</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="blake3-section">
                    <h3>BLAKE3 Hashing</h3>
                    <div class="blake3-info">
                        <div class="blake3-features">
                            <div class="feature">
                                <strong>âš¡ Speed</strong>
                                <p>Faster than MD5, SHA-1, SHA-256, SHA-3 on modern CPUs</p>
                            </div>
                            <div class="feature">
                                <strong>ğŸ”’ Security</strong>
                                <p>256-bit security level, resistant to length extension</p>
                            </div>
                            <div class="feature">
                                <strong>ğŸ”€ Parallelizable</strong>
                                <p>Scales with CPU cores for large data</p>
                            </div>
                            <div class="feature">
                                <strong>ğŸ”‘ KDF Mode</strong>
                                <p>Built-in key derivation with context separation</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="bao-section">
                    <h3>Bao Verified Streaming</h3>
                    <div class="bao-diagram">
                        <pre class="diagram-ascii">
                        Root Hash (32 bytes)
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                               â”‚
         Hash(L||R)                       Hash(L||R)
              â”‚                               â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                 â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
       â”‚             â”‚                 â”‚             â”‚
    Hash(L||R)   Hash(L||R)        Hash(L||R)   Hash(L||R)
       â”‚             â”‚                 â”‚             â”‚
    â”Œâ”€â”€â”´â”€â”€â”       â”Œâ”€â”€â”´â”€â”€â”          â”Œâ”€â”€â”´â”€â”€â”       â”Œâ”€â”€â”´â”€â”€â”
    â”‚     â”‚       â”‚     â”‚          â”‚     â”‚       â”‚     â”‚
  Chunk Chunk   Chunk Chunk      Chunk Chunk   Chunk Chunk
    1     2       3     4          5     6       7     8

  â€¢ Verify any chunk with O(log n) proof from root
  â€¢ Detect corruption before downloading entire file
  â€¢ Stream large files with incremental verification</pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Key Management -->
        <section id="key-management" class="security-section alt-bg">
            <h2>Key Management</h2>
            <p class="section-intro">How Fula handles key generation, storage, rotation, and recovery.</p>

            <div class="key-mgmt-details">
                <div class="key-generation">
                    <h3>Key Generation</h3>
                    <div class="generation-info">
                        <table class="config-table">
                            <tr>
                                <td><strong>Random Source</strong></td>
                                <td>OsRng (Operating System CSPRNG)</td>
                            </tr>
                            <tr>
                                <td><strong>KEK Generation</strong></td>
                                <td>32 random bytes â†’ X25519 secret key</td>
                            </tr>
                            <tr>
                                <td><strong>DEK Generation</strong></td>
                                <td>32 random bytes â†’ AES-256 key</td>
                            </tr>
                            <tr>
                                <td><strong>Nonce Generation</strong></td>
                                <td>12 random bytes per encryption</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <div class="key-rotation">
                    <h3>Key Rotation</h3>
                    <div class="rotation-process">
                        <div class="rotation-step">
                            <span class="rotation-num">1</span>
                            <div class="rotation-content">
                                <strong>Generate New KEK</strong>
                                <p>Create a fresh X25519 key pair</p>
                            </div>
                        </div>
                        <div class="rotation-step">
                            <span class="rotation-num">2</span>
                            <div class="rotation-content">
                                <strong>Re-wrap DEKs</strong>
                                <p>Decrypt each DEK with old KEK, re-encrypt with new KEK</p>
                            </div>
                        </div>
                        <div class="rotation-step">
                            <span class="rotation-num">3</span>
                            <div class="rotation-content">
                                <strong>Update Metadata</strong>
                                <p>Store new wrapped DEKs, increment version counter</p>
                            </div>
                        </div>
                        <div class="rotation-step">
                            <span class="rotation-num">4</span>
                            <div class="rotation-content">
                                <strong>Secure Delete Old KEK</strong>
                                <p>Zeroize old secret key from memory</p>
                            </div>
                        </div>
                    </div>
                    <div class="rotation-note">
                        <strong>Note:</strong> Data does NOT need to be re-encrypted - only the DEK wrappers change.
                    </div>
                </div>

                <div class="key-backup">
                    <h3>Key Backup & Recovery</h3>
                    <div class="backup-warning">
                        <span class="warning-icon">âš ï¸</span>
                        <div class="warning-content">
                            <strong>Critical: If you lose your secret key, your data is UNRECOVERABLE.</strong>
                            <p>Fula uses true end-to-end encryption. There are no backdoors, no "forgot password" recovery, no master keys.</p>
                        </div>
                    </div>
                    <div class="backup-options">
                        <h4>Recommended Backup Strategies</h4>
                        <ul>
                            <li><strong>Export as Base64:</strong> <code>secret_key.to_base64()</code> â†’ store in password manager</li>
                            <li><strong>Hardware Security Module:</strong> Store key in HSM or secure enclave</li>
                            <li><strong>Paper Backup:</strong> Print Base64 key, store in secure physical location</li>
                            <li><strong>Split Key:</strong> Use Shamir's Secret Sharing for distributed backup</li>
                        </ul>
                    </div>
                </div>

                <div class="key-zeroization">
                    <h3>Memory Security</h3>
                    <div class="zeroization-info">
                        <p>All key types implement <code>Zeroize</code> and <code>ZeroizeOnDrop</code>:</p>
                        <ul>
                            <li>Keys are automatically zeroed when dropped from memory</li>
                            <li>Prevents keys from lingering in memory after use</li>
                            <li>Protects against memory dump attacks</li>
                        </ul>
                        <div class="code-snippet">
                            <pre>// From fula-crypto/src/keys.rs
#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct SecretKey {
    bytes: [u8; 32],
}
// When SecretKey is dropped, bytes are overwritten with zeros</pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Secure Sharing -->
        <section id="sharing" class="security-section alt-bg">
            <h2>Secure File & Folder Sharing</h2>
            <p class="section-intro">Share files and folders with others without exposing your master key.</p>

            <div class="sharing-details">
                <div class="sharing-overview">
                    <h3>How Sharing Works</h3>
                    <p>Fula enables secure sharing through <strong>DEK-level access grants</strong>. When you share a file or folder, you encrypt only the relevant DEK for the recipient's public key - your master key (KEK) is never revealed.</p>
                    
                    <div class="sharing-diagram">
                        <pre class="diagram-ascii">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SHARE TOKEN CREATION                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Owner has:                    Recipient has:                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚ KEK (secret) â”‚              â”‚ KEK (secret) â”‚                 â”‚
â”‚  â”‚ File DEK     â”‚              â”‚ Public Key   â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚         â”‚                              â”‚                         â”‚
â”‚         â”‚ Owner encrypts DEK           â”‚                         â”‚
â”‚         â”‚ for recipient's public key   â”‚                         â”‚
â”‚         â–¼                              â”‚                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    SHARE TOKEN                              â”‚ â”‚
â”‚  â”‚  â€¢ wrapped_dek: HPKE.encrypt(recipient_pub, file_DEK)      â”‚ â”‚
â”‚  â”‚  â€¢ path_scope: "/photos/vacation/"                         â”‚ â”‚
â”‚  â”‚  â€¢ expires_at: 1735084800 (optional)                       â”‚ â”‚
â”‚  â”‚  â€¢ permissions: { read: true, write: false }               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                              â”‚                                   â”‚
â”‚                              â–¼                                   â”‚
â”‚  Recipient decrypts wrapped_dek using their secret key          â”‚
â”‚  â†’ Gets access to file_DEK only, NOT owner's KEK                â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
                    </div>
                </div>

                <div class="sharing-features">
                    <h3>Sharing Features</h3>
                    <div class="features-grid">
                        <div class="feature-item">
                            <strong>ğŸ“ Folder-Level Sharing</strong>
                            <p>Share entire folders by path prefix (e.g., <code>/photos/2024/</code>). Recipients can access all files in that path.</p>
                        </div>
                        <div class="feature-item">
                            <strong>â° Time-Limited Access</strong>
                            <p>Set expiration timestamps on shares. After expiry, the share token is rejected automatically.</p>
                        </div>
                        <div class="feature-item">
                            <strong>ğŸ” Permission Control</strong>
                            <p>Grant read-only, read-write, or full access. Permissions are enforced at share validation.</p>
                        </div>
                        <div class="feature-item">
                            <strong>ğŸš« Revocation</strong>
                            <p>Revoke shares at any time by removing them from your share list. Revoked tokens are rejected.</p>
                        </div>
                    </div>
                </div>

                <div class="sharing-code">
                    <h3>Code Example</h3>
                    <div class="code-snippet">
                        <pre>use fula_crypto::{KekKeyPair, DekKey, ShareBuilder, ShareRecipient};

// Owner creates a share for a folder
let owner = KekKeyPair::generate();
let recipient = KekKeyPair::generate();
let folder_dek = DekKey::generate();

let share = ShareBuilder::new(&owner, recipient.public_key(), &folder_dek)
    .path_scope("/photos/vacation/")
    .expires_in(7 * 24 * 60 * 60)  // 1 week
    .read_only()
    .build()?;

// Recipient accepts and uses the share
let handler = ShareRecipient::new(&recipient);
let access = handler.accept_share(&share)?;

// access.dek can now decrypt files in /photos/vacation/
// access.is_path_allowed("/photos/vacation/beach.jpg") == true
// access.is_path_allowed("/documents/secret.pdf") == false</pre>
                    </div>
                </div>

                <div id="complete-sharing-example" class="sharing-complete-example">
                    <h3>Complete Sharing Example: Alice Shares Photos with Bob</h3>
                    <p>This end-to-end example shows how sharing works in Fula, from key setup through content access:</p>
                    
                    <div class="code-snippet">
                        <pre>use fula_crypto::{
    // Key management
    KekKeyPair, DekKey, KeyManager,
    // Sharing primitives
    ShareBuilder, ShareRecipient, SharePermissions, ShareMode, SnapshotBinding,
    // Inbox for async/offline sharing
    ShareEnvelopeBuilder, ShareInbox,
    // Secret links
    SecretLinkBuilder, SecretLink,
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETUP: Alice and Bob each have their own key pairs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Alice (owner) creates her identity
let alice_keypair = KekKeyPair::generate();
let alice_public_key = alice_keypair.public_key().clone();

// Bob (recipient) creates his identity
let bob_keypair = KekKeyPair::generate();
let bob_public_key = bob_keypair.public_key().clone();

// Alice has encrypted files with a DEK for her /photos/ folder
let photos_dek = DekKey::generate();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTION 1: Direct Share (synchronous - both online)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Alice creates a share token for Bob
let share_token = ShareBuilder::new(
    &alice_keypair,           // Alice's keypair (for future signing)
    &bob_public_key,          // Bob's public key (DEK encrypted for him)
    &photos_dek,              // The DEK that decrypts the files
)
    .path_scope("/photos/vacation/")  // Bob can only access this folder
    .expires_in(7 * 24 * 3600)        // Expires in 1 week
    .read_only()                       // Bob cannot modify files
    .build()?;

// Alice sends share_token to Bob (via any channel - encrypted for Bob only)
// The token contains: wrapped DEK, path scope, expiry, permissions

// Bob receives and accepts the share
let bob_handler = ShareRecipient::new(&bob_keypair);
let access = bob_handler.accept_share(&share_token)?;

// Bob can now decrypt files in /photos/vacation/
assert!(access.is_path_allowed("/photos/vacation/beach.jpg"));  // âœ“ allowed
assert!(!access.is_path_allowed("/photos/family/"));             // âœ— denied
assert!(access.can_read);                                        // âœ“ read access
assert!(!access.can_write);                                      // âœ— no write

// Bob uses access.dek to decrypt file content:
// let plaintext = aead.decrypt(&nonce, &ciphertext)?;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTION 2: Secret Link (shareable URL with key in fragment)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Alice creates a secret link she can send via email/chat
let secret_link = SecretLinkBuilder::new(&share_token, "https://gateway.functionland.io")
    .label("Hawaii Trip 2024")
    .build()?;

let url = secret_link.to_url()?;
// => "https://gateway.functionland.io/fula/share/abc123#eyJ2ZXJzaW9uIjoxLC..."
//    Server sees: /fula/share/abc123 (opaque ID)
//    Client sees: #... fragment with encrypted token

// Bob opens the link in his browser/app
let parsed_link = SecretLink::parse(&url)?;
let extracted_token = parsed_link.extract_token();

// Bob accepts and uses it as above
let access = bob_handler.accept_share(&extracted_token)?;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTION 3: Async Inbox (offline sharing - Bob picks up later)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Alice creates a share envelope with rich metadata
let (envelope, inbox_entry) = ShareEnvelopeBuilder::new(
    &alice_keypair,
    &bob_public_key,
    &photos_dek,
)
    .path_scope("/photos/vacation/")
    .expires_in(7 * 24 * 3600)
    .read_only()
    .label("Hawaii Trip 2024")                    // Human-readable label
    .message("Hey Bob, check out these pics!")    // Personal message
    .sharer_name("Alice")                         // Sharer display name
    .metadata("album", "vacation-2024")           // Custom metadata
    .build()?;

// Alice stores the inbox entry for Bob (via PrivateForest)
let inbox_path = ShareInbox::entry_storage_path(&bob_public_key, &inbox_entry.id);
// => "/.fula/inbox/&lt;bob-key-hash&gt;/&lt;entry-id&gt;.share"

// Later: Bob comes online and checks his inbox
let mut bob_inbox = ShareInbox::new();

// Bob loads entries from storage
bob_inbox.add_entry(inbox_entry);

// Bob lists pending shares
let pending = bob_inbox.list_pending(&bob_keypair);
println!("You have {} new shares", pending.len());  // "You have 1 new shares"

// Bob accepts Alice's share
let entry_id = pending[0].id.clone();
let accepted_envelope = bob_inbox.accept_entry(&entry_id, &bob_keypair)?;

println!("From: {:?}", accepted_envelope.sharer_name);    // "Alice"
println!("Message: {:?}", accepted_envelope.message);     // "Hey Bob, check out..."
println!("Path: {}", accepted_envelope.token.path_scope); // "/photos/vacation/"

// Bob uses the ShareToken from the envelope
let access = bob_handler.accept_share(&accepted_envelope.token)?;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPTION 4: Snapshot Share (immutable version only)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Alice wants to share a specific report version that won't change
let report_hash = "abc123def456...";  // BLAKE3 hash of file content
let report_size = 1024;               // File size in bytes
let report_modified = 1699876543;     // Modification timestamp

let snapshot_share = ShareBuilder::new(&alice_keypair, &bob_public_key, &photos_dek)
    .path_scope("/documents/report.pdf")
    .snapshot_with(report_hash, report_size, report_modified)  // Bind to version
    .read_only()
    .build()?;

// Later: Bob tries to access the file
let current_hash = "abc123def456...";  // Current file hash
if snapshot_share.is_snapshot_valid(current_hash) {
    // File hasn't changed, access granted
    let access = bob_handler.accept_share(&snapshot_share)?;
} else {
    // File was modified, snapshot share is no longer valid
    println!("The shared file has been modified since the share was created");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SUMMARY: Who Controls What
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ALICE (Application/Owner) decides:
//   - WHO to share with (Bob's public key)
//   - WHAT to share (path scope)
//   - HOW LONG (expiry)
//   - WHAT PERMISSIONS (read/write/delete)
//   - WHAT MODE (temporal vs snapshot)
//
// FULA PROTOCOL handles:
//   - HPKE encryption of DEK so only Bob can decrypt
//   - Unique share ID generation
//   - Expiry validation
//   - Path scope enforcement
//   - Snapshot binding verification
//   - Inbox entry encryption
//   - Secret link key isolation (fragment never sent to server)</pre>
                    </div>
                </div>

                <div class="sharing-security">
                    <h3>Security Properties</h3>
                    <ul>
                        <li><strong>Master Key Isolation:</strong> Owner's KEK is never transmitted or revealed</li>
                        <li><strong>Cryptographic Enforcement:</strong> Only intended recipient can decrypt the DEK</li>
                        <li><strong>Time-Bound Access:</strong> Expired tokens are cryptographically validated and rejected</li>
                        <li><strong>Path Scoping:</strong> Recipients cannot access files outside their granted scope</li>
                    </ul>
                </div>

                <div id="secret-links" class="sharing-secret-links">
                    <h3>Secret Links (Peergos-Inspired)</h3>
                    <p>Fula supports <strong>secret link URL patterns</strong> where all sensitive key material is kept in the URL fragment (<code>#...</code>), which is never sent to the server.</p>
                    
                    <div class="code-snippet">
                        <pre>URL Format:
https://gateway.example/fula/share/&lt;opaque-id&gt;#&lt;base64url-encoded-payload&gt;

Server sees: /fula/share/abc123 (opaque ID for logging/rate-limits)
Client sees: Fragment containing encrypted ShareToken with DEK and permissions

Example:
https://gateway.example/fula/share/a1b2c3d4#eyJ2ZXJzaW9uIjoxLCJ0b2tlbiI6ey...</pre>
                    </div>

                    <div class="code-snippet">
                        <pre>use fula_crypto::{SecretLink, SecretLinkBuilder, ShareBuilder, KekKeyPair, DekKey};

// Create a share token
let owner = KekKeyPair::generate();
let recipient = KekKeyPair::generate();
let dek = DekKey::generate();

let token = ShareBuilder::new(&owner, recipient.public_key(), &dek)
    .path_scope("/photos/vacation/")
    .expires_in(3600)  // 1 hour
    .read_only()
    .build()?;

// Create a secret link (key material only in fragment)
let link = SecretLinkBuilder::new(&token, "https://gateway.example")
    .label("Vacation Photos 2024")
    .build()?;

let url = link.to_url()?;
// => "https://gateway.example/fula/share/abc123#eyJ2ZXJzaW9uIjoxLC..."

// Parse a received secret link
let parsed = SecretLink::parse(&url)?;
let extracted_token = parsed.extract_token();

// Gateway never sees the key material in the fragment!</pre>
                    </div>

                    <h4>Security Benefits</h4>
                    <ul>
                        <li><strong>Fragment Privacy:</strong> URL fragments are never sent to servers in HTTP requests</li>
                        <li><strong>Key Isolation:</strong> Gateway cannot decrypt shared content even if compromised</li>
                        <li><strong>Revocation Support:</strong> Opaque ID can be checked against a server-side revocation list</li>
                        <li><strong>URL-Safe:</strong> Uses base64url encoding (no <code>+</code> or <code>/</code> characters)</li>
                    </ul>
                </div>

                <div id="share-modes" class="sharing-modes">
                    <h3>Snapshot vs Temporal Share Modes (WNFS-Inspired)</h3>
                    <p>Fula supports two share modes that determine how access evolves over time, inspired by WNFS's <code>AccessKey</code> semantics:</p>
                    
                    <div class="mode-comparison">
                        <div class="mode-card temporal">
                            <h4>ğŸ”„ Temporal Mode (Default)</h4>
                            <p>Recipients always see the <strong>latest version</strong> of shared content.</p>
                            <ul>
                                <li>Access to current state of files/folders</li>
                                <li>Updates by owner are visible to recipients</li>
                                <li>Best for ongoing collaboration</li>
                            </ul>
                        </div>
                        <div class="mode-card snapshot">
                            <h4>ğŸ“¸ Snapshot Mode</h4>
                            <p>Recipients can only access the <strong>exact version</strong> at share creation time.</p>
                            <ul>
                                <li>Bound to specific content hash, size, and timestamp</li>
                                <li>If content changes, share becomes invalid</li>
                                <li>Best for compliance, auditing, or "point-in-time" sharing</li>
                            </ul>
                        </div>
                    </div>

                    <div class="code-snippet">
                        <pre>use fula_crypto::{ShareBuilder, SnapshotBinding, ShareMode, KekKeyPair, DekKey};

let owner = KekKeyPair::generate();
let recipient = KekKeyPair::generate();
let dek = DekKey::generate();

// Temporal share (default) - access evolves with content
let temporal_share = ShareBuilder::new(&owner, recipient.public_key(), &dek)
    .path_scope("/photos/vacation/")
    .temporal()  // or omit - temporal is default
    .build()?;

// Snapshot share - bound to specific content version
let snapshot_share = ShareBuilder::new(&owner, recipient.public_key(), &dek)
    .path_scope("/documents/contract.pdf")
    .snapshot_with(
        "abc123def456",  // content hash (BLAKE3)
        102400,          // size in bytes
        1700000000,      // modification timestamp
    )
    .build()?;

// Verify snapshot is still valid
let verification = snapshot_share.verify_snapshot(
    "abc123def456",  // current content hash
    102400,          // current size
    1700000000,      // current timestamp
)?;
assert_eq!(verification, SnapshotVerification::Valid);

// Quick check
assert!(snapshot_share.is_snapshot_valid("abc123def456"));
assert!(!snapshot_share.is_snapshot_valid("different_hash"));</pre>
                    </div>

                    <h4>When to Use Each Mode</h4>
                    <table class="mode-table">
                        <thead>
                            <tr>
                                <th>Use Case</th>
                                <th>Recommended Mode</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Sharing a folder for ongoing collaboration</td>
                                <td><strong>Temporal</strong></td>
                            </tr>
                            <tr>
                                <td>Sharing a signed contract for audit trail</td>
                                <td><strong>Snapshot</strong></td>
                            </tr>
                            <tr>
                                <td>Giving access to a photo album that may be updated</td>
                                <td><strong>Temporal</strong></td>
                            </tr>
                            <tr>
                                <td>Sharing a specific version of a report</td>
                                <td><strong>Snapshot</strong></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Async Inbox Sharing -->
        <section id="async-inbox" class="security-section alt-bg">
            <h2>Async/Offline Inbox Sharing (WNFS-Inspired)</h2>
            <p class="section-intro">Store-and-forward sharing where recipients can pick up shares later without the sharer being online.</p>

            <div class="inbox-content">
                <div class="inbox-overview">
                    <h3>How It Works</h3>
                    <p>Inspired by WNFS's exchange directories, Fula supports asynchronous sharing where:</p>
                    <ul>
                        <li><strong>Sharer</strong> creates an encrypted <code>ShareEnvelope</code> and stores it in the recipient's inbox</li>
                        <li><strong>Recipient</strong> can later list, decrypt, and accept shares when convenient</li>
                        <li><strong>No coordination</strong> required - both parties can be offline at different times</li>
                    </ul>
                    
                    <div class="diagram-box">
                        <pre class="diagram-ascii">
Sharer                          Storage                         Recipient
  â”‚                                â”‚                                â”‚
  â”‚ 1. Create ShareEnvelope        â”‚                                â”‚
  â”‚    + HPKE encrypt for recipientâ”‚                                â”‚
  â”‚                                â”‚                                â”‚
  â”‚ 2. Store in inbox â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â–º[Encrypted entry stored]       â”‚
  â”‚                                â”‚                                â”‚
  â”‚                                â”‚  [Later, recipient comes online]
  â”‚                                â”‚                                â”‚
  â”‚                                â”‚â—„â”€â”€3. List inbox entries â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                â”‚                                â”‚
  â”‚                                â”‚â—„â”€â”€4. Decrypt & accept â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
  â”‚                                â”‚                                â”‚
  â”‚                                â”‚  5. Use ShareToken to access   â”‚
  â”‚                                â”‚     shared content             â”‚</pre>
                    </div>
                </div>

                <div class="code-snippet">
                    <pre>use fula_crypto::{ShareEnvelopeBuilder, ShareInbox, KekKeyPair, DekKey};

// === SHARER FLOW ===
let sharer = KekKeyPair::generate();
let recipient = KekKeyPair::generate();
let dek = DekKey::generate();

// Create share envelope with metadata
let (envelope, entry) = ShareEnvelopeBuilder::new(
    &sharer,
    recipient.public_key(),
    &dek
)
    .path_scope("/photos/vacation/")
    .expires_in(7 * 24 * 3600)  // 1 week
    .read_only()
    .label("Vacation Photos 2024")
    .message("Check out these pics from Hawaii!")
    .sharer_name("Alice")
    .build()?;

// Store entry in recipient's inbox (via PrivateForest)
let inbox_path = ShareInbox::entry_storage_path(recipient.public_key(), &entry.id);
// put_object_flat(bucket, &inbox_path, serialize(&entry), ...);

// === RECIPIENT FLOW ===
let mut inbox = ShareInbox::new();

// Load entries from storage
inbox.add_entry(entry);

// List pending shares
let pending = inbox.list_pending(&recipient);
println!("You have {} new shares", pending.len());

// Accept a share
let accepted = inbox.accept_entry(&entry_id, &recipient)?;
println!("From: {:?}", accepted.sharer_name);  // "Alice"
println!("Message: {:?}", accepted.message);   // "Check out these pics..."

// Now use the ShareToken to access content
let dek = recipient.accept_share(&accepted.token)?;</pre>
                </div>

                <div class="inbox-features">
                    <h3>Key Features</h3>
                    <div class="benefits-grid">
                        <div class="benefit-card">
                            <strong>ğŸ“¬ Offline Delivery</strong>
                            <p>Shares are stored encrypted until recipient comes online</p>
                        </div>
                        <div class="benefit-card">
                            <strong>ğŸ”’ End-to-End Encrypted</strong>
                            <p>Only recipient can decrypt inbox entries using HPKE</p>
                        </div>
                        <div class="benefit-card">
                            <strong>ğŸ“ Rich Metadata</strong>
                            <p>Include labels, messages, and sharer info with each share</p>
                        </div>
                        <div class="benefit-card">
                            <strong>â° Auto-Expiry</strong>
                            <p>Configurable TTL for inbox entries (default: 30 days)</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Subtree Keys (Cryptree-Style) -->
        <section id="subtree-keys" class="security-section">
            <h2>Subtree Keys (Peergos Cryptree-Inspired)</h2>
            <p class="section-intro">Allocate separate DEKs for major folders for better revocation and least privilege.</p>

            <div class="subtree-content">
                <div class="subtree-overview">
                    <h3>What are Subtree Keys?</h3>
                    <p>Inspired by <a href="https://book.peergos.org/security/cryptree.html">Peergos Cryptree</a>, Fula supports a <strong>shallow key hierarchy</strong> where top-level folders can have their own DEKs:</p>
                    
                    <div class="diagram-box">
                        <pre class="diagram-ascii">
Master DEK (bucket-level)
     â”‚
     â”œâ”€â”€ /photos/ â”€â”€â”€ Subtree DEK A â”€â”€â”€ [beach.jpg, sunset.jpg, ...]
     â”‚
     â”œâ”€â”€ /documents/ â”€â”€â”€ Subtree DEK B â”€â”€â”€ [report.pdf, notes.txt, ...]
     â”‚
     â””â”€â”€ /apps/myapp/ â”€â”€â”€ Subtree DEK C â”€â”€â”€ [config.json, data.bin, ...]

Sharing /photos/ only exposes Subtree DEK A.
Revoking that share only requires re-keying /photos/, not the whole bucket.</pre>
                    </div>
                </div>

                <div class="subtree-benefits">
                    <h3>Key Benefits</h3>
                    <div class="benefits-grid">
                        <div class="benefit-card">
                            <strong>ğŸ”„ Efficient Revocation</strong>
                            <p>Re-key just one subtree instead of rotating the entire bucket</p>
                        </div>
                        <div class="benefit-card">
                            <strong>ğŸ”’ Least Privilege</strong>
                            <p>A subtree share cannot be escalated to access unrelated data</p>
                        </div>
                        <div class="benefit-card">
                            <strong>âš¡ Low Overhead</strong>
                            <p>Still uses a single PrivateForest - no structural changes needed</p>
                        </div>
                    </div>
                </div>

                <div class="code-snippet">
                    <pre>use fula_crypto::{SubtreeKeyManager, SubtreeShareBuilder, DekKey, KekKeyPair};

// Create manager with master DEK
let master_dek = DekKey::generate();
let mut manager = SubtreeKeyManager::with_master_dek(master_dek);

// Create subtrees with their own DEKs
let (photos_dek, encrypted_photos) = manager.create_subtree("/photos/")?;
let (docs_dek, encrypted_docs) = manager.create_subtree("/documents/")?;

// Resolve DEK for a file path
let dek = manager.resolve_dek("/photos/vacation/beach.jpg");  // Returns photos_dek

// Share a subtree with someone
let owner = KekKeyPair::generate();
let recipient = KekKeyPair::generate();

let share = SubtreeShareBuilder::new(
    &owner,
    recipient.public_key(),
    &photos_dek,
    "/photos/",
    1,  // version
)
    .expires_in(86400)  // 24 hours
    .read_only()
    .build()?;

// Rotate subtree key after revocation
let rotation = manager.rotate_subtree("/photos/")?;
// rotation.new_dek is now used for /photos/*
// Old shares become invalid</pre>
                </div>

                <div class="subtree-use-cases">
                    <h3>When to Use Subtree Keys</h3>
                    <table class="mode-table">
                        <thead>
                            <tr>
                                <th>Scenario</th>
                                <th>Recommendation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Sharing app-specific data folders</td>
                                <td>Use subtree DEK per app namespace</td>
                            </tr>
                            <tr>
                                <td>Sharing project folders with different teams</td>
                                <td>Use subtree DEK per project</td>
                            </tr>
                            <tr>
                                <td>Need to revoke access to specific shared folder</td>
                                <td>Rotate just that subtree's DEK</td>
                            </tr>
                            <tr>
                                <td>Single user, no sharing</td>
                                <td>Master DEK is sufficient</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Key Rotation Details -->
        <section id="key-rotation-detail" class="security-section">
            <h2>Full Filesystem Key Rotation</h2>
            <p class="section-intro">Rotate your KEK without re-encrypting file content.</p>

            <div class="rotation-details">
                <div class="rotation-overview">
                    <h3>Why Rotate Keys?</h3>
                    <ul>
                        <li><strong>Suspected Compromise:</strong> If you think your key might be exposed</li>
                        <li><strong>Regular Security Hygiene:</strong> Periodic rotation limits exposure window</li>
                        <li><strong>Personnel Changes:</strong> When someone with key access leaves</li>
                        <li><strong>Compliance Requirements:</strong> Some regulations mandate key rotation</li>
                    </ul>
                </div>

                <div class="rotation-diagram">
                    <h3>Rotation Process</h3>
                    <div class="diagram-box">
                        <pre class="diagram-ascii">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      KEY ROTATION FLOW                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  BEFORE ROTATION:                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     wraps      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  KEK v1     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚   DEK A    â”‚â”€â”€â†’ File A        â”‚
â”‚  â”‚ (current)   â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚  â”‚             â”‚     wraps      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚             â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚   DEK B    â”‚â”€â”€â†’ File B        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                  â”‚
â”‚  ROTATION STEP 1: Generate new KEK                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚  KEK v1     â”‚                â”‚  KEK v2     â”‚                 â”‚
â”‚  â”‚ (previous)  â”‚                â”‚ (current)   â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                  â”‚
â”‚  ROTATION STEP 2: Re-wrap each DEK                               â”‚
â”‚                                                                  â”‚
â”‚  For each file:                                                  â”‚
â”‚    1. Decrypt DEK with KEK v1                                    â”‚
â”‚    2. Re-encrypt DEK with KEK v2                                 â”‚
â”‚    3. Update wrapped DEK in metadata                             â”‚
â”‚                                                                  â”‚
â”‚  AFTER ROTATION:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     wraps      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚  KEK v2     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚   DEK A    â”‚â”€â”€â†’ File A        â”‚
â”‚  â”‚ (current)   â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   (unchanged)    â”‚
â”‚  â”‚             â”‚     wraps      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚             â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚   DEK B    â”‚â”€â”€â†’ File B        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   (unchanged)    â”‚
â”‚                                                                  â”‚
â”‚  Note: File content is NEVER re-encrypted!                       â”‚
â”‚        Only the DEK wrappers are updated.                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
                    </div>
                </div>

                <div class="rotation-code">
                    <h3>Code Example</h3>
                    <div class="code-snippet">
                        <pre>use fula_crypto::{KekKeyPair, DekKey, FileSystemRotation};

// Initialize with current keypair
let keypair = KekKeyPair::generate();
let mut fs = FileSystemRotation::new(keypair)
    .with_batch_size(100);  // Process 100 files per batch

// Register existing files
for file in files {
    fs.wrap_new_file(&file.path, &file.dek)?;
}

// Initiate rotation (generates new KEK)
let new_public_key = fs.rotate();

// Rotate in batches (for large filesystems)
while !fs.is_rotation_complete() {
    let result = fs.rotate_batch();
    println!("Rotated {} files", result.rotated_count);
}

// All files now use KEK v2
// Old KEK is automatically cleared</pre>
                    </div>
                </div>

                <div class="rotation-benefits">
                    <h3>Key Benefits</h3>
                    <div class="benefits-grid">
                        <div class="benefit-card">
                            <strong>âš¡ Efficient</strong>
                            <p>Only re-wraps DEKs (32 bytes each), never re-encrypts file content</p>
                        </div>
                        <div class="benefit-card">
                            <strong>ğŸ“¦ Incremental</strong>
                            <p>Process files in batches to avoid overwhelming large systems</p>
                        </div>
                        <div class="benefit-card">
                            <strong>ğŸ”„ Backward Compatible</strong>
                            <p>Old wrapped keys still work during transition period</p>
                        </div>
                        <div class="benefit-card">
                            <strong>âœ… Verified</strong>
                            <p>Track rotation progress and verify completion</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Metadata Privacy -->
        <section id="metadata-privacy" class="security-section alt-bg">
            <h2>Metadata Privacy</h2>
            <p class="section-intro">Protect not just your data, but also your file names, sizes, and timestamps.</p>

            <div class="privacy-details">
                <div class="privacy-overview">
                    <h3>Why Metadata Privacy Matters</h3>
                    <p>Even with encrypted content, metadata can reveal sensitive information:</p>
                    <ul>
                        <li><strong>File names</strong> like "tax_returns_2024.pdf" or "medical_records.docx" reveal intent</li>
                        <li><strong>File sizes</strong> can identify document types or media content</li>
                        <li><strong>Timestamps</strong> show when you accessed or modified files</li>
                        <li><strong>Content types</strong> indicate what kind of data you're storing</li>
                    </ul>
                </div>

                <div class="privacy-how">
                    <h3>How It Works</h3>
                    <div class="privacy-diagram">
                        <pre class="diagram-ascii">
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   METADATA PRIVACY FLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  CLIENT SIDE (Original Metadata):                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Key:        /finances/investment_portfolio_2024.xlsx       â”‚ â”‚
â”‚  â”‚ Size:       156,789 bytes                                  â”‚ â”‚
â”‚  â”‚ Type:       application/vnd.openxmlformats...              â”‚ â”‚
â”‚  â”‚ Modified:   2024-12-07T15:30:00Z                           â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                      â”‚
â”‚                           â–¼                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              METADATA ENCRYPTION                           â”‚ â”‚
â”‚  â”‚  1. Create PrivateMetadata struct with original values    â”‚ â”‚
â”‚  â”‚  2. Encrypt with file's DEK using AES-256-GCM             â”‚ â”‚
â”‚  â”‚  3. Generate obfuscated storage key via BLAKE3            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                           â”‚                                      â”‚
â”‚                           â–¼                                      â”‚
â”‚  SERVER SIDE (What storage nodes see):                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Key:        e/a7c3f9b2e8d14a6f (obfuscated hash)          â”‚ â”‚
â”‚  â”‚ Size:       156,821 bytes (ciphertext size)               â”‚ â”‚
â”‚  â”‚ Type:       application/octet-stream (generic)            â”‚ â”‚
â”‚  â”‚ Metadata:   [encrypted blob]                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</pre>
                    </div>
                </div>

                <div class="privacy-modes">
                    <h3>Key Obfuscation Modes</h3>
                    <div class="modes-grid">
                        <div class="mode-card recommended">
                            <h4>ğŸŒŸ FlatNamespace (DEFAULT)</h4>
                            <p>Complete structure hiding. Server sees only random CID-like hashes. Inspired by WNFS and Peergos.</p>
                            <code>/photos/beach.jpg â†’ QmX7a8f3e2d1c9b4a5</code>
                            <small>No prefixes, no structure hints. Directory tree stored in encrypted PrivateForest index.</small>
                        </div>
                        <div class="mode-card">
                            <h4>DeterministicHash</h4>
                            <p>Same file path â†’ Same storage key. Allows retrieval without local index.</p>
                            <code>/photos/beach.jpg â†’ e/a7c3f9b2e8d14a6f</code>
                        </div>
                        <div class="mode-card">
                            <h4>RandomUuid</h4>
                            <p>Each upload gets a random key. Maximum privacy but requires local mapping.</p>
                            <code>/photos/beach.jpg â†’ e/random-uuid-here</code>
                        </div>
                        <div class="mode-card">
                            <h4>PreserveStructure</h4>
                            <p>Keep directory paths, hash only filenames. Allows folder browsing.</p>
                            <code>/photos/beach.jpg â†’ /photos/e_a7c3f9b2</code>
                        </div>
                    </div>
                </div>

                <div class="privacy-code">
                    <h3>Code Example</h3>
                    <div class="code-snippet">
                        <pre>use fula_client::{EncryptedClient, EncryptionConfig, KeyObfuscation};

// DEFAULT: FlatNamespace for complete structure hiding
let encryption = EncryptionConfig::new();  // FlatNamespace by default!
let client = EncryptedClient::new(config, encryption)?;

// Upload - server sees: QmX7a8f3e2d1c9b4a5e6f7d8...
client.put_object_flat(bucket, "/secret/file.txt", data, None).await?;

// List files from encrypted PrivateForest index
let files = client.list_files_from_forest(bucket).await?;

// Server sees NOTHING about your folder structure!

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Alternative modes (for specific use cases):
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// DeterministicHash - same path = same key, no local index needed
let encryption = EncryptionConfig::new()
    .with_obfuscation_mode(KeyObfuscation::DeterministicHash);

// PreserveStructure - keeps folder paths visible
let encryption = EncryptionConfig::new()
    .with_obfuscation_mode(KeyObfuscation::PreserveStructure);

// Disable metadata privacy entirely (not recommended)
let encryption = EncryptionConfig::new_without_privacy();

// Get full metadata including original filename
let info = client.get_object_with_private_metadata(bucket, storage_key).await?;
println!("Original name: {}", info.original_key);
println!("Original size: {}", info.original_size);</pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- Security Guarantees -->
        <section id="security-guarantees" class="security-section">
            <h2>Security Guarantees</h2>
            <p class="section-intro">What the current implementation provides and its limitations.</p>

            <div class="guarantees-grid">
                <div class="guarantee-card provided">
                    <h3>âœ… Provided</h3>
                    <ul>
                        <li><strong>Confidentiality:</strong> Data encrypted with AES-256-GCM; only key holder can decrypt</li>
                        <li><strong>Integrity:</strong> AEAD tags detect any tampering with ciphertext</li>
                        <li><strong>Authenticity:</strong> Only holder of secret key can produce valid decryption</li>
                        <li><strong>Forward Secrecy:</strong> Ephemeral keys in HPKE protect past data</li>
                        <li><strong>Key Isolation:</strong> Each file has unique DEK; compromise affects only that file</li>
                        <li><strong>Semantic Security:</strong> Same plaintext encrypts to different ciphertext each time</li>
                        <li><strong>Ciphertext Indistinguishability:</strong> Encrypted data appears random</li>
                        <li><strong>Metadata Privacy:</strong> File names, sizes, timestamps encrypted (optional, enabled by default)</li>
                    </ul>
                </div>

                <div class="guarantee-card not-provided">
                    <h3>âŒ Not Provided</h3>
                    <ul>
                        <li><strong>Sender Authentication:</strong> Recipients can't verify who encrypted the data</li>
                        <li><strong>Deniability:</strong> Encryption proves you had the key</li>
                        <li><strong>Traffic Analysis Resistance:</strong> Access patterns may be observable</li>
                        <li><strong>Post-Quantum Security:</strong> X25519 vulnerable to quantum computers</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Threat Model -->
        <section id="threat-model" class="security-section alt-bg">
            <h2>Threat Model</h2>
            <p class="section-intro">What attacks Fula protects against and what it doesn't.</p>

            <div class="threat-analysis">
                <div class="threat-category protected">
                    <h3>ğŸ›¡ï¸ Protected Against</h3>
                    <div class="threat-list">
                        <div class="threat-item">
                            <strong>Malicious Storage Nodes</strong>
                            <p>Nodes only see encrypted data. They cannot read your files or forge valid data.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Network Eavesdroppers</strong>
                            <p>All data in transit is encrypted. Even if intercepted, it's unreadable.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Data Tampering</strong>
                            <p>AEAD tags and content addressing detect any modifications.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Gateway Compromise</strong>
                            <p>Gateway never sees plaintext or keys. Compromise only affects availability, not confidentiality.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Replay Attacks</strong>
                            <p>Unique nonces prevent replaying old ciphertexts.</p>
                        </div>
                    </div>
                </div>

                <div class="threat-category not-protected">
                    <h3>âš ï¸ Not Protected Against</h3>
                    <div class="threat-list">
                        <div class="threat-item">
                            <strong>Compromised Client Device</strong>
                            <p>If your device is compromised, attacker can extract keys.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Rubber Hose Cryptanalysis</strong>
                            <p>Coercion/legal compulsion to reveal keys.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Side-Channel Attacks</strong>
                            <p>Timing, power analysis on the local device.</p>
                        </div>
                        <div class="threat-item">
                            <strong>Quantum Computers</strong>
                            <p>X25519 can be broken by sufficiently powerful quantum computers.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Multi-Device Key Management -->
        <section id="multi-device" class="security-section">
            <h2>Multi-Device Key Management</h2>
            <p class="section-intro">Securely manage encryption keys across multiple devices.</p>

            <div class="multi-device-content">
                <div class="patterns-overview">
                    <h3>Key Management Patterns</h3>
                    <p>Fula supports multiple patterns for managing keys across devices:</p>
                    
                    <div class="pattern-cards">
                        <div class="pattern-card">
                            <h4>Pattern A: Shared Identity</h4>
                            <p>All devices share the same master key. Simple but all devices are equally trusted.</p>
                            <div class="code-snippet">
                                <pre>// All devices use same backed-up secret
let master_secret = SecretKey::from_bytes(backed_up_secret)?;
let keypair = KekKeyPair::from_secret(master_secret);
let key_manager = KeyManager::new(&keypair);
// Files encrypted on one device readable on all</pre>
                            </div>
                            <div class="pattern-pros-cons">
                                <span class="pro">+ Simple setup</span>
                                <span class="pro">+ Seamless sync</span>
                                <span class="con">- No device revocation</span>
                            </div>
                        </div>

                        <div class="pattern-card recommended">
                            <span class="badge">Recommended</span>
                            <h4>Pattern B: Per-Device Keys</h4>
                            <p>Each device has its own KEK. Access granted via ShareToken.</p>
                            <div class="code-snippet">
                                <pre>// Device A (primary)
let device_a = KekKeyPair::generate();

// Device B (secondary) 
let device_b = KekKeyPair::generate();

// Grant Device B access to specific folders
let share = ShareBuilder::new(
    &device_a,
    device_b.public_key(),
    &folder_dek
)
    .path_scope("/shared/")
    .build()?;</pre>
                            </div>
                            <div class="pattern-pros-cons">
                                <span class="pro">+ Device revocation</span>
                                <span class="pro">+ Granular access</span>
                                <span class="con">- More complex setup</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="device-loss">
                    <h3>Handling Device Loss</h3>
                    <p>When a device is lost or stolen:</p>
                    <ol>
                        <li><strong>Immediate:</strong> Rotate KEK on remaining devices</li>
                        <li><strong>Re-wrap:</strong> Use <code>FileSystemRotation</code> to re-wrap all DEKs</li>
                        <li><strong>Revoke:</strong> Remove device from any shared access</li>
                        <li><strong>Audit:</strong> Review what data the device had access to</li>
                    </ol>
                    <div class="code-snippet">
                        <pre>// On remaining device - rotate immediately
let mut rotation = FileSystemRotation::new(current_keypair);
let new_public_key = rotation.rotate();

// Re-wrap all DEKs with new KEK
while !rotation.is_rotation_complete() {
    rotation.rotate_batch();
}
// Lost device's wrapped keys are now useless</pre>
                    </div>
                </div>

                <div class="key-backup">
                    <h3>Key Backup Strategy</h3>
                    <div class="backup-options">
                        <div class="backup-option">
                            <strong>ğŸ“ Paper Backup</strong>
                            <p>24-word mnemonic phrase stored offline in multiple secure locations</p>
                        </div>
                        <div class="backup-option">
                            <strong>ğŸ” Hardware Security</strong>
                            <p>YubiKey, Ledger, or other HSM for master key storage</p>
                        </div>
                        <div class="backup-option">
                            <strong>â˜ï¸ Encrypted Cloud</strong>
                            <p>Password-protected backup on different provider than data</p>
                        </div>
                    </div>
                </div>

                <div class="recovery-info">
                    <h3>Recovery Scenarios</h3>
                    <table class="recovery-table">
                        <thead>
                            <tr>
                                <th>Scenario</th>
                                <th>Recovery Method</th>
                                <th>Data Loss</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Lost device (backup exists)</td>
                                <td>Restore from backup</td>
                                <td class="success">None</td>
                            </tr>
                            <tr>
                                <td>Lost device (no backup)</td>
                                <td>Cannot recover</td>
                                <td class="danger">All data</td>
                            </tr>
                            <tr>
                                <td>Compromised device (detected early)</td>
                                <td>Rotate + restore</td>
                                <td class="success">None</td>
                            </tr>
                            <tr>
                                <td>Compromised device (delayed detection)</td>
                                <td>Rotate + audit</td>
                                <td class="warning">Potentially exposed</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <p class="doc-link">
                    ğŸ“„ <strong>Full Documentation:</strong> See <a href="https://github.com/functionland/fula-api/blob/main/docs/THREAT_MODEL.md">THREAT_MODEL.md</a> for comprehensive multi-device patterns and threat analysis.
                </p>
            </div>
        </section>

        <!-- Best Practices -->
        <section id="best-practices" class="security-section alt-bg">
            <h2>Security Best Practices</h2>
            <p class="section-intro">Recommendations for securely using Fula encryption.</p>

            <div class="practices-grid">
                <div class="practice-card">
                    <div class="practice-icon">ğŸ”‘</div>
                    <h3>Key Management</h3>
                    <ul>
                        <li>Generate keys on a secure, trusted device</li>
                        <li>Back up your secret key in multiple secure locations</li>
                        <li>Never share or transmit your secret key</li>
                        <li>Rotate keys periodically or after potential compromise</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ’»</div>
                    <h3>Client Security</h3>
                    <ul>
                        <li>Keep your device and OS updated</li>
                        <li>Use full-disk encryption</li>
                        <li>Use a hardware security module if available</li>
                        <li>Clear keys from memory after use</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ”’</div>
                    <h3>Data Handling</h3>
                    <ul>
                        <li>Always enable encryption for sensitive data</li>
                        <li>Verify file integrity after download</li>
                        <li>Don't store sensitive metadata in unencrypted fields</li>
                        <li>Use unique DEKs per file (default behavior)</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <div class="practice-icon">ğŸ”„</div>
                    <h3>Operational Security</h3>
                    <ul>
                        <li>Monitor for unauthorized access attempts</li>
                        <li>Have an incident response plan for key compromise</li>
                        <li>Test key recovery procedures periodically</li>
                        <li>Audit encryption settings regularly</li>
                    </ul>
                </div>
            </div>
        </section>

        <footer>
            <p>Fula API Security Documentation â€¢ Built with â¤ï¸ for decentralized security</p>
            <p class="footer-links">
                <a href="https://github.com/functionland/fula-api">GitHub</a> â€¢
                <a href="https://fx.land">Functionland</a>
            </p>
        </footer>
    </main>

    <script src="js/app.js"></script>
</body>
</html>
