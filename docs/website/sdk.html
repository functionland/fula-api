<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>SDK Examples - Fula API Documentation</title>
    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script>
        (function() {
            const saved = localStorage.getItem('fula-docs-theme');
            if (saved) document.documentElement.setAttribute('data-theme', saved);
        })();
    </script>
</head>
<body>
    <!-- Mobile Header -->
    <header class="mobile-header">
        <button class="hamburger" aria-label="Toggle menu">
            <span></span>
            <span></span>
            <span></span>
        </button>
        <span class="logo-text">Fula API</span>
        <div class="mobile-header-actions">
            <button class="theme-toggle" aria-label="Toggle theme">
                <span class="icon-sun">‚òÄÔ∏è</span>
                <span class="icon-moon">üåô</span>
            </button>
        </div>
    </header>
    
    <div class="sidebar-overlay"></div>
    
    <nav class="sidebar">
        <div class="sidebar-header">
            <div class="logo">
                <h1>Fula API</h1>
                <span class="version">v0.1.0</span>
            </div>
            <button class="theme-toggle" aria-label="Toggle theme">
                <span class="icon-sun">‚òÄÔ∏è</span>
                <span class="icon-moon">üåô</span>
            </button>
        </div>
        <div class="nav-section">
            <h3>Documentation</h3>
            <ul>
                <li><a href="index.html">Introduction</a></li>
                <li><a href="security.html">Security & Encryption</a></li>
                <li><a href="api.html">API Reference</a></li>
                <li><a href="sdk.html" class="active">SDK Examples</a></li>
                <li><a href="platforms.html">Platform Guides</a></li>
            </ul>
        </div>
        <div class="nav-section">
            <h3>SDK Examples</h3>
            <ul>
                <li><a href="#rust-client">Rust Client</a></li>
                <li><a href="#encryption">Encryption</a></li>
                <li><a href="#metadata-privacy">Metadata Privacy</a></li>
                <li><a href="#file-manager">File Manager API</a></li>
                <li><a href="#secure-sharing">Secure Sharing</a></li>
                <li><a href="#multipart">Multipart Uploads</a></li>
                <li><a href="#aws-cli">AWS CLI</a></li>
                <li><a href="#python">Python (boto3)</a></li>
                <li><a href="#javascript">JavaScript</a></li>
            </ul>
        </div>
    </nav>

    <main class="content">
        <div class="section-header">
            <h1>SDK Examples</h1>
            <p>Code examples for integrating with the Fula API using various languages and tools.</p>
        </div>

        <section id="rust-client" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>Rust Client SDK</h2>
                    <p>The official Rust client provides type-safe access to all Fula API operations with built-in encryption support.</p>
                    
                    <h3>Installation</h3>
                    <p>Add to your <code>Cargo.toml</code>:</p>
                    
                    <h3>Features</h3>
                    <ul>
                        <li><strong>Type-safe</strong> - Compile-time guarantees</li>
                        <li><strong>Async/await</strong> - Built on Tokio</li>
                        <li><strong>Encryption</strong> - HPKE client-side encryption</li>
                        <li><strong>Streaming</strong> - Efficient large file handling</li>
                    </ul>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Cargo.toml</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-toml">[dependencies]
fula-client = "0.1"
tokio = { version = "1", features = ["full"] }</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Basic Usage</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::{FulaClient, ClientConfig};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create client
    let config = ClientConfig::new("http://localhost:9000")
        .with_token("your-auth-token");
    let client = FulaClient::new(config).await?;

    // Create bucket
    client.create_bucket("my-bucket").await?;

    // Upload object
    let data = b"Hello, Fula!";
    let etag = client.put_object("my-bucket", "hello.txt", data).await?;
    println!("Uploaded with ETag: {}", etag);

    // Download object
    let content = client.get_object("my-bucket", "hello.txt").await?;
    println!("Content: {}", String::from_utf8_lossy(&content));

    // List objects
    let objects = client.list_objects("my-bucket", None).await?;
    for obj in objects {
        println!("  {} ({} bytes)", obj.key, obj.size);
    }

    // Delete object
    client.delete_object("my-bucket", "hello.txt").await?;

    Ok(())
}</code></pre>
                </div>
            </div>
        </section>

        <section id="encryption" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>Client-Side Encryption</h2>
                    <p>Fula supports transparent client-side encryption using HPKE (Hybrid Public Key Encryption).</p>
                    
                    <h3>How It Works</h3>
                    <ol>
                        <li>Generate or load a key pair</li>
                        <li>Data is encrypted locally before upload</li>
                        <li>Only you can decrypt the data</li>
                        <li>Server never sees plaintext</li>
                    </ol>
                    
                    <h3>Encryption Features</h3>
                    <ul>
                        <li><strong>HPKE</strong> - RFC 9180 compliant</li>
                        <li><strong>BLAKE3</strong> - Fast, secure hashing</li>
                        <li><strong>Bao</strong> - Verified streaming</li>
                        <li><strong>X25519</strong> - Elliptic curve DH</li>
                    </ul>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Encrypted Upload/Download</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::{FulaClient, ClientConfig, EncryptionConfig};
use fula_crypto::keys::KekKeyPair;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Generate encryption keys
    let keypair = KekKeyPair::generate();
    
    // Configure client with encryption
    let config = ClientConfig::new("http://localhost:9000")
        .with_token("your-auth-token")
        .with_encryption(EncryptionConfig::new(keypair));
    
    let client = FulaClient::new(config).await?;

    // Upload encrypted data
    let sensitive_data = b"This is encrypted before upload";
    client.put_object_encrypted(
        "secure-bucket",
        "secret.txt",
        sensitive_data
    ).await?;

    // Download and decrypt
    let decrypted = client.get_object_decrypted(
        "secure-bucket",
        "secret.txt"
    ).await?;

    assert_eq!(sensitive_data.as_slice(), decrypted.as_slice());
    println!("Decrypted: {}", String::from_utf8_lossy(&decrypted));

    Ok(())
}</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Key Management</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_crypto::keys::{KekKeyPair, KeyManager};

// Generate new key pair
let keypair = KekKeyPair::generate();

// Export for backup (encrypt this!)
let private_bytes = keypair.secret_key().to_bytes();
let public_bytes = keypair.public_key().to_bytes();

// Restore from bytes
let restored = KekKeyPair::from_bytes(&private_bytes)?;

// Key manager for multiple keys
let mut manager = KeyManager::new(keypair);
manager.add_recipient("alice", alice_public_key);
manager.add_recipient("bob", bob_public_key);</code></pre>
                </div>
            </div>
        </section>

        <!-- Metadata Privacy Section -->
        <section id="metadata-privacy" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>üîí Metadata Privacy</h2>
                    <p>Protect not just your file content, but also file names, sizes, and timestamps from the server.</p>
                    
                    <h3>What's Protected</h3>
                    <ul>
                        <li><strong>File Names</strong> - Server sees obfuscated hash, not "tax_returns_2024.pdf"</li>
                        <li><strong>File Sizes</strong> - Server sees ciphertext size, not original</li>
                        <li><strong>Content Types</strong> - Server sees "application/octet-stream"</li>
                        <li><strong>Timestamps</strong> - Encrypted in private metadata</li>
                        <li><strong>User Metadata</strong> - All custom fields encrypted</li>
                    </ul>
                    
                    <h3>Obfuscation Modes</h3>
                    <ul>
                        <li><strong>FlatNamespace (Default)</strong> - Complete structure hiding, maximum privacy</li>
                        <li><strong>DeterministicHash</strong> - Same path ‚Üí same key</li>
                        <li><strong>RandomUuid</strong> - Random key per upload</li>
                        <li><strong>PreserveStructure</strong> - Keep folders, hash filenames</li>
                    </ul>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Metadata Privacy (Enabled by Default)</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::{EncryptedClient, EncryptionConfig, KeyObfuscation, Config};

// FlatNamespace (maximum privacy) is ENABLED by default
let encryption = EncryptionConfig::new();

// Or customize the obfuscation mode
let encryption = EncryptionConfig::new()
    .with_obfuscation_mode(KeyObfuscation::PreserveStructure);

// Disable if not needed (not recommended)
let encryption = EncryptionConfig::new_without_privacy();

let config = Config::new("http://localhost:9000").with_token("token");
let client = EncryptedClient::new(config, encryption)?;

// Upload - server sees: "e/a7c3f9b2e8d14a6f"
// You use:               "/finances/tax_2024.pdf"
client.put_object_encrypted(bucket, "/finances/tax_2024.pdf", data).await?;

// Retrieve using original path
let data = client.get_object_decrypted(bucket, "/finances/tax_2024.pdf").await?;</code></pre>

                    <div class="example-header">
                        <span class="lang-label">What Server Sees vs What You See</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">// SERVER'S VIEW (Storage Node):
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ Key:    e/a7c3f9b2e8d14a6f                      ‚îÇ
// ‚îÇ Size:   156,821 bytes (ciphertext)             ‚îÇ
// ‚îÇ Type:   application/octet-stream               ‚îÇ
// ‚îÇ Data:   [encrypted blob]                       ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// YOUR VIEW (Client):
// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
// ‚îÇ Key:    /finances/tax_2024.pdf                 ‚îÇ
// ‚îÇ Size:   156,789 bytes (original)               ‚îÇ
// ‚îÇ Type:   application/pdf                        ‚îÇ
// ‚îÇ Data:   [decrypted PDF document]               ‚îÇ
// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>

                    <div class="example-header">
                        <span class="lang-label">FlatNamespace Mode (RECOMMENDED)</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::{EncryptedClient, EncryptionConfig, Config};

// FlatNamespace provides COMPLETE structure hiding
// Inspired by WNFS and Peergos
let encryption = EncryptionConfig::new_flat_namespace();

let config = Config::new("http://localhost:9000").with_token("token");
let client = EncryptedClient::new(config, encryption)?;

// Upload - server sees: "QmX7a8f3e2d1c9b4a5e6f7d8c9a0b1e2f3"
// NO prefix, NO structure hints!
client.put_object_flat(bucket, "/photos/vacation/beach.jpg", data, None).await?;

// Server CANNOT determine:
// ‚Ä¢ Which objects are files vs folders
// ‚Ä¢ Parent/child relationships
// ‚Ä¢ How many files in each "folder"
// ‚Ä¢ Any directory structure

// List files from encrypted PrivateForest index
let files = client.list_files_from_forest(bucket).await?;
for file in files {
    println!("{} - {}", file.original_key, file.size_human());
}</code></pre>
                </div>
            </div>
        </section>

        <!-- File Manager API Section -->
        <section id="file-manager" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>üìÅ File Manager API</h2>
                    <p>Browse encrypted files <strong>without downloading content</strong>. Perfect for file managers, sync tools, and directory browsers.</p>
                    
                    <h3>Key Benefits</h3>
                    <ul>
                        <li><strong>Bandwidth Efficient</strong> - Only ~1-2KB per file (headers only)</li>
                        <li><strong>Fast Browsing</strong> - List 1000 files without downloading 1GB</li>
                        <li><strong>Decrypted Names</strong> - See real filenames, not hashes</li>
                        <li><strong>Full Metadata</strong> - Size, type, timestamps, custom fields</li>
                    </ul>
                    
                    <h3>Operations</h3>
                    <ul>
                        <li><code>head_object_decrypted()</code> - Single file metadata</li>
                        <li><code>list_objects_decrypted()</code> - All files with metadata</li>
                        <li><code>list_directory()</code> - Tree structure view</li>
                    </ul>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">List Files Without Downloading Content</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::{EncryptedClient, EncryptionConfig, Config};

let client = EncryptedClient::new(config, EncryptionConfig::new())?;

// List ALL files with decrypted metadata - NO content download!
let files = client.list_objects_decrypted(bucket, None).await?;

for file in &files {
    println!("üìÑ {} ({}) - {}",
        file.filename(),           // "report.pdf" (decrypted)
        file.size_human(),         // "1.5 MB"
        file.content_type.as_deref().unwrap_or("unknown")
    );
}

// Total bandwidth: ~1KB per file (just headers)
// NOT: downloading entire file content</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Get Single File Metadata (HEAD Request)</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">// Get metadata WITHOUT downloading content
let metadata = client.head_object_decrypted(bucket, storage_key).await?;

println!("Original name: {}", metadata.original_key);
println!("Size: {} bytes", metadata.original_size);
println!("Type: {:?}", metadata.content_type);
println!("Created: {:?}", metadata.created_at);
println!("Modified: {:?}", metadata.modified_at);

// Only download content when user clicks "Open"
if user_wants_to_open {
    let content = client.get_object_decrypted_by_storage_key(
        bucket, &metadata.storage_key
    ).await?;
}</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Directory Tree View</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">// Get files grouped by directory
let listing = client.list_directory(bucket, Some("/photos/")).await?;

println!("üìä {} files, {} total", 
    listing.file_count(), 
    format_size(listing.total_size())
);

for dir in listing.get_directories() {
    println!("\nüìÅ {}/", dir);
    
    if let Some(files) = listing.get_files(dir) {
        for file in files {
            let icon = match file.content_type.as_deref() {
                Some(t) if t.starts_with("image/") => "üñºÔ∏è",
                Some(t) if t.starts_with("video/") => "üé¨",
                Some(t) if t.contains("pdf") => "üìÑ",
                _ => "üìÑ",
            };
            println!("   {} {} ({})", icon, file.filename(), file.size_human());
        }
    }
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Secure Sharing Section -->
        <section id="secure-sharing" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>ü§ù Secure Sharing</h2>
                    <p>Share files and folders with others without exposing your master key.</p>
                    
                    <h3>Features</h3>
                    <ul>
                        <li><strong>Path-Scoped</strong> - Share specific folders, not everything</li>
                        <li><strong>Time-Limited</strong> - Set expiry for temporary access</li>
                        <li><strong>Permissions</strong> - Read, write, delete controls</li>
                        <li><strong>Revocable</strong> - Cancel access anytime</li>
                        <li><strong>Zero Knowledge</strong> - Server can't read shared content</li>
                    </ul>
                    
                    <h3>How It Works</h3>
                    <ol>
                        <li>Create share token with recipient's public key</li>
                        <li>DEK is re-encrypted for recipient (not shared directly)</li>
                        <li>Recipient decrypts with their private key</li>
                        <li>Your master key is never exposed</li>
                    </ol>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Share a File with Someone</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_crypto::{
    KekKeyPair, DekKey,
    sharing::{ShareBuilder, ShareToken, AcceptedShare},
    hpke::SharePermissions,
};

// Alice (owner) wants to share with Bob
let alice_keypair = KekKeyPair::generate();
let bob_keypair = KekKeyPair::generate();
let file_dek = DekKey::generate(); // File's encryption key

// Create share token for Bob (expires in 7 days)
let share_token = ShareBuilder::new(
    &alice_keypair,
    bob_keypair.public_key(),
    &file_dek,
)
.with_path_scope("/photos/vacation/")  // Only this folder
.with_expiry_days(7)                    // 7 days access
.with_permissions(SharePermissions::read_only())
.build()?;

// Send token to Bob (via any channel)
let token_json = serde_json::to_string(&share_token)?;</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Accept a Share (Recipient Side)</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">// Bob receives the share token
let share_token: ShareToken = serde_json::from_str(&token_json)?;

// Verify and accept
let accepted = AcceptedShare::accept(&share_token, &bob_keypair)?;

// Now Bob can decrypt files in /photos/vacation/
let decrypted_dek = accepted.dek();

// Check permissions
if accepted.can_write() {
    // Bob can modify files
}

if accepted.is_expired() {
    // Access has expired
}</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Folder Sharing with Manager</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_crypto::sharing::FolderShareManager;

// Create share manager for a folder
let mut share_manager = FolderShareManager::new(
    owner_keypair.clone(),
    "/documents/project-x/".to_string(),
);

// Add multiple recipients
share_manager.add_recipient(
    "alice",
    alice_public_key,
    SharePermissions::read_write(),
)?;

share_manager.add_recipient(
    "bob", 
    bob_public_key,
    SharePermissions::read_only(),
)?;

// Revoke access
share_manager.revoke("bob")?;

// Check who has access
for (name, _) in share_manager.list_recipients() {
    println!("Shared with: {}", name);
}</code></pre>
                </div>
            </div>
        </section>

        <section id="multipart" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>Multipart Uploads</h2>
                    <p>Upload large files efficiently using multipart uploads with progress tracking.</p>
                    
                    <h3>Benefits</h3>
                    <ul>
                        <li><strong>Resumable</strong> - Continue failed uploads</li>
                        <li><strong>Parallel</strong> - Upload parts concurrently</li>
                        <li><strong>Progress</strong> - Track upload progress</li>
                        <li><strong>Large files</strong> - Up to 5TB per object</li>
                    </ul>
                    
                    <h3>Part Size</h3>
                    <p>Default: 5MB per part. Minimum: 5MB (except last part).</p>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Large File Upload with Progress</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::multipart::upload_large_file;
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = Arc::new(FulaClient::new(config).await?);
    
    // Read large file
    let data = std::fs::read("large-video.mp4")?;
    
    // Upload with progress callback
    let etag = upload_large_file(
        client,
        "media-bucket",
        "videos/large-video.mp4",
        data.into(),
        Some(Box::new(|progress| {
            println!(
                "Uploading: {:.1}% ({}/{} bytes) - Part {}/{}",
                progress.percentage(),
                progress.bytes_uploaded,
                progress.total_bytes,
                progress.current_part,
                progress.total_parts
            );
        })),
    ).await?;

    println!("Upload complete! ETag: {}", etag);
    Ok(())
}</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Manual Multipart Control</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-rust">use fula_client::multipart::MultipartUpload;

// Start multipart upload
let mut upload = MultipartUpload::start(
    client.clone(),
    "bucket",
    "large-file.zip"
).await?;

println!("Upload ID: {}", upload.upload_id());

// Upload parts
for (i, chunk) in data.chunks(5 * 1024 * 1024).enumerate() {
    let etag = upload.upload_part((i + 1) as u32, chunk).await?;
    println!("Part {} uploaded: {}", i + 1, etag);
}

// Complete upload
let final_etag = upload.complete().await?;
println!("Complete: {}", final_etag);</code></pre>
                </div>
            </div>
        </section>

        <section id="aws-cli" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>AWS CLI</h2>
                    <p>Use the standard AWS CLI with Fula's S3-compatible endpoint.</p>
                    
                    <h3>Configuration</h3>
                    <p>Configure AWS CLI to use the Fula endpoint:</p>
                    
                    <h3>Supported Commands</h3>
                    <ul>
                        <li><code>aws s3 ls</code> - List buckets/objects</li>
                        <li><code>aws s3 cp</code> - Upload/download</li>
                        <li><code>aws s3 rm</code> - Delete objects</li>
                        <li><code>aws s3 mb</code> - Create bucket</li>
                        <li><code>aws s3 rb</code> - Remove bucket</li>
                        <li><code>aws s3 sync</code> - Sync directories</li>
                    </ul>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Configuration</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-bash"># Configure credentials
aws configure set aws_access_key_id YOUR_ACCESS_KEY
aws configure set aws_secret_access_key YOUR_SECRET_KEY

# Set endpoint alias
alias fula='aws --endpoint-url http://localhost:9000'</code></pre>

                    <div class="example-header">
                        <span class="lang-label">Common Operations</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-bash"># List all buckets
fula s3 ls

# Create bucket
fula s3 mb s3://my-bucket

# Upload file
fula s3 cp ./local-file.txt s3://my-bucket/remote-file.txt

# Upload directory
fula s3 cp ./my-folder s3://my-bucket/folder/ --recursive

# Download file
fula s3 cp s3://my-bucket/remote-file.txt ./downloaded.txt

# List objects with prefix
fula s3 ls s3://my-bucket/prefix/

# Delete object
fula s3 rm s3://my-bucket/old-file.txt

# Sync local to remote
fula s3 sync ./local-dir s3://my-bucket/backup/

# Delete bucket (must be empty)
fula s3 rb s3://my-bucket</code></pre>
                </div>
            </div>
        </section>

        <section id="python" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>Python (boto3)</h2>
                    <p>Use the official AWS SDK for Python with Fula's S3-compatible API.</p>
                    
                    <h3>Installation</h3>
                    <code class="inline-code">pip install boto3</code>
                    
                    <h3>Features</h3>
                    <ul>
                        <li>Full S3 API compatibility</li>
                        <li>Automatic retries</li>
                        <li>Multipart upload support</li>
                        <li>Streaming transfers</li>
                    </ul>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">Python Example</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-python">import boto3
from botocore.config import Config

# Create client
s3 = boto3.client(
    's3',
    endpoint_url='http://localhost:9000',
    aws_access_key_id='YOUR_ACCESS_KEY',
    aws_secret_access_key='YOUR_SECRET_KEY',
    config=Config(signature_version='s3v4')
)

# Create bucket
s3.create_bucket(Bucket='my-bucket')

# Upload file
s3.upload_file('local-file.txt', 'my-bucket', 'remote-file.txt')

# Upload with metadata
s3.put_object(
    Bucket='my-bucket',
    Key='document.pdf',
    Body=open('document.pdf', 'rb'),
    ContentType='application/pdf',
    Metadata={'author': 'John Doe'}
)

# Download file
s3.download_file('my-bucket', 'remote-file.txt', 'downloaded.txt')

# List objects
response = s3.list_objects_v2(Bucket='my-bucket', Prefix='docs/')
for obj in response.get('Contents', []):
    print(f"{obj['Key']} - {obj['Size']} bytes")

# Delete object
s3.delete_object(Bucket='my-bucket', Key='old-file.txt')

# Presigned URL (for sharing)
url = s3.generate_presigned_url(
    'get_object',
    Params={'Bucket': 'my-bucket', 'Key': 'file.txt'},
    ExpiresIn=3600  # 1 hour
)
print(f"Share URL: {url}")</code></pre>
                </div>
            </div>
        </section>

        <section id="javascript" class="endpoint">
            <div class="endpoint-content">
                <div class="description">
                    <h2>JavaScript / TypeScript</h2>
                    <p>Use the AWS SDK for JavaScript with Fula's S3-compatible endpoint.</p>
                    
                    <h3>Installation</h3>
                    <code class="inline-code">npm install @aws-sdk/client-s3</code>
                    
                    <h3>Browser Support</h3>
                    <p>Works in Node.js and browsers with proper CORS configuration.</p>
                </div>
                <div class="example">
                    <div class="example-header">
                        <span class="lang-label">TypeScript Example</span>
                        <button class="copy-btn" onclick="copyCode(this)">Copy</button>
                    </div>
                    <pre><code class="language-typescript">import {
  S3Client,
  CreateBucketCommand,
  PutObjectCommand,
  GetObjectCommand,
  ListObjectsV2Command,
  DeleteObjectCommand,
} from '@aws-sdk/client-s3';

// Create client
const s3 = new S3Client({
  endpoint: 'http://localhost:9000',
  region: 'us-east-1',
  credentials: {
    accessKeyId: 'YOUR_ACCESS_KEY',
    secretAccessKey: 'YOUR_SECRET_KEY',
  },
  forcePathStyle: true, // Required for S3-compatible services
});

async function main() {
  // Create bucket
  await s3.send(new CreateBucketCommand({
    Bucket: 'my-bucket',
  }));

  // Upload object
  await s3.send(new PutObjectCommand({
    Bucket: 'my-bucket',
    Key: 'hello.txt',
    Body: 'Hello, Fula!',
    ContentType: 'text/plain',
  }));

  // Download object
  const response = await s3.send(new GetObjectCommand({
    Bucket: 'my-bucket',
    Key: 'hello.txt',
  }));
  const content = await response.Body?.transformToString();
  console.log('Content:', content);

  // List objects
  const list = await s3.send(new ListObjectsV2Command({
    Bucket: 'my-bucket',
    Prefix: 'docs/',
  }));
  for (const obj of list.Contents ?? []) {
    console.log(`${obj.Key} - ${obj.Size} bytes`);
  }

  // Delete object
  await s3.send(new DeleteObjectCommand({
    Bucket: 'my-bucket',
    Key: 'hello.txt',
  }));
}

main().catch(console.error);</code></pre>
                </div>
            </div>
        </section>

        <footer>
            <p>Fula API Documentation ‚Ä¢ Built with ‚ù§Ô∏è for decentralized storage</p>
        </footer>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>
    <script src="js/app.js"></script>
</body>
</html>
